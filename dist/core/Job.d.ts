import { IJob, JobHooks, JobParams } from "../types";
import { JobExecutionError } from "./JobExecutionError";
import { Queue } from "./Queue";
import { Task } from "./Task";
export declare class Job implements IJob {
    readonly name?: string;
    protected queue: Queue<{
        task: Task;
        args: unknown[];
    }>;
    protected _startedAt: number;
    protected _endedAt: number;
    protected _stoppedAt?: number | undefined;
    protected _isRunning: boolean;
    protected _hasErrors: JobExecutionError[];
    protected hooks: JobHooks;
    protected execAsync?: boolean;
    protected results: unknown[];
    protected shouldStop: boolean;
    private logger;
    constructor(params?: JobParams);
    addHook(hook: "onSuccess", fn: <T = unknown[]>(result: T) => void | Promise<void>): this;
    addHook(hook: "beforeStart", fn: (job: Job) => void | Promise<void>): this;
    addHook(hook: "onError", fn: (error: JobExecutionError) => void | Promise<void>): this;
    addHook(hook: "beforeAll", fn: () => void | Promise<void>): this;
    addHook(hook: "beforeEach", fn: (task: Task<unknown, unknown[]>) => void | Promise<void>): this;
    addHook(hook: "beforeClose", fn: () => void | Promise<void>): this;
    addHook(hook: "afterEach", fn: (task: Task<unknown, unknown[]>) => void | Promise<void>): this;
    addHook(hook: "afterAll", fn: (job: Job) => void | Promise<void>): this;
    addHook(hook: "afterClose", fn: () => void | Promise<void>): this;
    addHook(hook: "onFinish", fn: <T = unknown[]>(errors: JobExecutionError[], results: T) => void | Promise<void>): void;
    addTask(task: Task<any, any[]>, ...fnArgs: unknown[]): Job;
    run(): Promise<void>;
    stop(): void;
    get hasErrors(): JobExecutionError[];
    get startedAt(): number;
    get endedAt(): number;
    get stoppedAt(): number;
    get isRunning(): boolean;
}
